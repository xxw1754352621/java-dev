# [内存结构](https://mp.weixin.qq.com/s/ebxRu1oh6L_WtoIS3CBF9A)

- 五大区域
  - 程序计数器
  - 虚拟机栈
  - 本地方法栈
  - 堆区
  - 方法区

# 垃圾收集器关注的区域

- 堆区和方法区
- 其他区域的声明周期跟随线程

# 常见的算法

- 引用计数法
- 可达性分析法
  - GC Roots
    -  虚拟机栈中引用的对象（栈帧中的本地变量表）；
    - 方法区中类静态属性引用的对象；
    - 方法区中常量引用的对象；
    - 本地方法栈中JNI（Native方法）引用的对象。

# 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关

- 强引用 >软引用 >弱引用 >虚引用

# 堆区的对象回收

真正执行System.gc()，至少需要**两次标记**

- 可达性分析算法，没有与GC Roots相连接的引用链的对象，第一次标记

- 第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。在`finalize()`方法中没有重新与引用链建立关联关系的，将被进行第二次标记。

  - finalize()方法，是父类Object的方法，不重载，就是空方法。

    ```java
    protected void finalize() throws Throwable { }
    ```

# 方法区的对象回收

方法区主要回收的内容有：**废弃常量和无用的类。**

对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的`ClassLoader`已经被回收；
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 常见的垃圾回收算法

1. 标记-清除算法

   - 思路：标记完毕后（二次标记），当前位置清除
   - 问题：内存碎片

2. 复制算法

   - 为了克服句柄的开销和解决内存碎片的问题
   - 思路：堆分成 一个对象面和多个空闲面
   - 缺点：占用内存

3. 标记-整理算法

   - 思路：当前回收的位置，其他位置的对象移位到这个位置，使其内存充分利用

   - 缺点：占用cpu，成本高

4. **分代收集（Generational Collection）**

   - 大部分JVM采用的垃圾收集器算法，**每个区的算法采用不一样的策略**
   - 思路：根据对象存活的生命周期将内存划分为若干个不同的区域。
     - 堆区内
       - 新生区-Young Generation（三个小区的比例，8:1:1）
         - eden区
         - 两个survivor(survivor0,survivor1)区
       - 老年区-Tenured Generation
     - 堆区外
       - 永生代-Permanet Generation
       
  
   - ##### 算法总结

     当前商业虚拟机的垃圾收集都采用**分代收集（Generational Collection）算法**，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：
   
  - **新生代** 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。
     - **老年代** 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**“标记-清除”**或**“标记-整理”**算法来进行回收。

   # [常见的垃圾收集器](https://juejin.im/post/5bade237e51d450ea401fd71)

   - **Serial收集器（复制算法)**
  新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过`-XX:+UseSerialGC`来强制指定。
   

   

   
- **Serial Old收集器(标记-整理算法)**
   
  老年代单线程收集器，Serial收集器的老年代版本。
   

   

   
- **ParNew收集器(停止-复制算法)**　
   
  新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。
   

   
- **Parallel Scavenge收集器(停止-复制算法)**
   
  并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用`-XX:+UseParallelGC`来强制指定，用`-XX:ParallelGCThreads=4`来指定线程数。
   

   
- **Parallel Old收集器(停止-复制算法)**
   
     Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。
   
   
   
   - **CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**
   
     高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。