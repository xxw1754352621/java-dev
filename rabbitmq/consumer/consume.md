# 消费者的确认模式（AcknowledgeMode）
  - 自动确认
    - 当服务端推送到消费端的时候，就认为消息投递成功，如果消费端在正常的处理过程中
     消费端被kill -9的话，就会丢失数据

  - 手动确认
     - 要等消费端完全消费之后，手动跟服务端确认消息已经消费完成，这样保证消息不丢失
       但是减低tps
# 预期消息数量（prefetch） 
  -  Maximum number of unacknowledged messages that can be outstanding 
    at each consumer.
  -  根据消费端的时候消息情况配置大小，消费能力越强，设置数量可以越大
  -  一般来讲，数据也大，消费端就也能帮服务端分压
  
# 消息消费过程：
  - 消息直接消费，队列进程到 C端
  - 消息出队
      - 1.正在获取消息的处理
        - 判断q4是否为空
          - 不为空，返回
          - 为空，从q3获取
            - q3为空，直接返回空
            - q3不为空，直接返回
      - 2.获取消息后的处理
        - q4不为空，不处理
        - q4为空，后面有代码继续从q3拉取数据
          - 此时q3不为空，往q4转移
            - 转移后，判断q3是否为空
              - 不为空，不处理
              - 为空，delta转移到q3，
              - 为空，delta为空的同时，q2转移到q3
              - q3和delta都为空，则认为队列为空
              - 此时q1直接转移到q4，不经过磁盘
  
  - 3.下次消费，同1