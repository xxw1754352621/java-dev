# 缓存一致性（最终一致性）

方案

## 1. update data，update cache

- 问题：脏数据，方案不可取

- 原因分析：**更新脏数据到缓存**

  - ```sql
    【A写 B写】
    - A线程更新数据库
    - B线程更新数据库
    - B线程更新缓存
    - A更新【脏数据】到缓存
    ```

    

## 2. delete cache， update data

- 问题：读取依然是**旧数据**

- 原因分析：**缓存删除导致**

  - ```
    【A写 B读】
    - A线程删除缓存
    - B线程读取数据库（缓存已删除）
    - B线程更新缓存
    - A线程更新数据库
    ```

- 变种方案，双删除（直接采用方案3）：

  ```
  - 同上
  - A线程更新数据库后
  - A线程睡眠，等待B线程更新完缓存
    - 等待时间大小设置
      - B读取数据的一般时间 + 缓存更新时间+ mysql主从同步时间等 其他额外耗时计算
  - A线程再删除一次缓存
  ```

  

## 3. update data，delete cache

- 问题：读取依然是**旧数据**（同2）

- 原因分析：缓存过期，**写比读快导致**

  - ```
    【A写 B读】
    - 缓存过期
    - B读取数据（旧数据）
    - A更新数据
    - A删除缓存
    - B更新缓存（旧数据）
    ```

- 建议采取这种方案，读一般比写快，这种发生的可能性不大，其他分析

  

# 缓存一致性（强一致性）

问题：吞吐量低，并发低，适用读多写少，不建议

分析：**写阻塞**

```
【A写 B读】
- 缓存过期
- B线程读（旧数据）
- B线程无缓存，读数据库
- B加锁
- A线程阻塞
- B更新缓存
- B释放锁
- A线程获取锁
```

