# [内存结构](https://mp.weixin.qq.com/s/ebxRu1oh6L_WtoIS3CBF9A)

- 五大区域
  - 程序计数器
  - 虚拟机栈
  - 本地方法栈
  - 堆区
  - 方法区

# 垃圾收集器关注的区域

- 堆区和方法区
- 其他区域的声明周期跟随线程

# 常见的算法

- 引用计数法
- 可达性分析法
  - GC Roots
    -  虚拟机栈中引用的对象（栈帧中的本地变量表）；
    - 方法区中类静态属性引用的对象；
    - 方法区中常量引用的对象；
    - 本地方法栈中JNI（Native方法）引用的对象。

# 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关

- 强引用 >软引用 >弱引用 >虚引用

# 堆区的对象回收

真正执行System.gc()，至少需要**两次标记**

- 可达性分析算法，没有与GC Roots相连接的引用链的对象，第一次标记

- 第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。在`finalize()`方法中没有重新与引用链建立关联关系的，将被进行第二次标记。

  - finalize()方法，是父类Object的方法，不重载，就是空方法。

    ```java
    protected void finalize() throws Throwable { }
    ```

# 方法区的对象回收

方法区主要回收的内容有：**废弃常量和无用的类。**

对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的`ClassLoader`已经被回收；
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 常见的垃圾回收算法

1. 标记-清除算法

   - 思路：标记完毕后（二次标记），当前位置清除
   - 问题：内存碎片

2. 复制算法

   - 为了克服句柄的开销和解决内存碎片的问题
   - 思路：堆分成 一个对象面和多个空闲面
   - 缺点：占用内存

3. 标记-整理算法

   - 思路：当前回收的位置，其他位置的对象移位到这个位置，使其内存充分利用

   - 缺点：占用cpu，成本高

4. **分代收集（Generational Collection）**

   - 大部分JVM采用的垃圾收集器算法，**每个区的算法采用不一样的策略**
   - 思路：根据对象存活的生命周期将内存划分为若干个不同的区域。
     - 堆区内
       - 新生区-Young Generation（三个小区的比例，8:1:1）
         - eden区
         - 两个survivor(survivor0,survivor1)区
       - 老年区-Tenured Generation
     - 堆区外
       - 永生代-Permanet Generation
       
   
   - ##### 算法总结

     当前商业虚拟机的垃圾收集都采用**分代收集（Generational Collection）算法**，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：
   
  - **新生代** 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。
     
     - **老年代** 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**“标记-清除”**或**“标记-整理”**算法来进行回收。
     
- **对复制算法进一步优化：使用Eden/S0/S1三个分区**

     平均分成A/B块太浪费内存，采用Eden/S0/S1三个区更合理，空间比例为Eden:S0:S1==8:1:1，有效内存（即可分配新生对象的内存）是总内存的9/10。

     算法过程：

     - Eden+S0可分配新生对象；
     - 对Eden+S0进行垃圾收集，存活对象复制到S1。清理Eden+S0。一次新生代GC结束。
     - Eden+S1可分配新生对象；
     - 对Eden+S1进行垃圾收集，存活对象复制到S0。清理Eden+S1。二次新生代GC结束。
     - goto 1

默认Eden:S0:S1=8:1:1,因此，新生代中可以使用的内存空间大小占用新生代的9/10,那么有人就会问，为什么不直接分成两个区，一个区占9/10,另一个区占1/10，这样做的原因大概有以下几种

1.S0与S1的区间明显较小，有效新生代空间为Eden+S0/S1，因此有效空间就大，增加了内存使用率
2.有利于对象代的计算，当一个对象在S0/S1中达到设置的XX:MaxTenuringThreshold值后，会将其分到老年代中，设想一下，如果没有S0/S1,直接分成两个区，该如何计算对象经过了多少次GC还没被释放,你可能会说，在对象里加一个计数器记录经过的GC次数，或者存在一张映射表记录对象和GC次数的关系，是的，可以，但是这样的话，会扫描整个新生代中的对象, 有了S0/S1我们就可以只扫描S0/S1区了

   # [常见的垃圾收集器](https://juejin.im/post/5bade237e51d450ea401fd71)

   - **Serial收集器（复制算法)**

    新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过`-XX:+UseSerialGC`来强制指定。





- **Serial Old收集器(标记-整理算法)**
  
  老年代单线程收集器，Serial收集器的老年代版本。
  

  

  
- **ParNew收集器(停止-复制算法)**　
  
  新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。
  

  
- **Parallel Scavenge收集器(停止-复制算法)**
  
  并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用`-XX:+UseParallelGC`来强制指定，用`-XX:ParallelGCThreads=4`来指定线程数。
  

  
- **Parallel Old收集器(停止-复制算法)**
  
     Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。

   

   - **CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**
   
     高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。

- 参考：[垃圾回收器](https://github.com/xxw1754352621/java-dev/blob/master/java%E5%9F%BA%E7%A1%80/JVM/GC/garbage-collector.md)