# 缓存一致性（最终一致性）

方案（建议方案3）

## 1. update data，update cache

- 问题：脏数据，方案不可取

- 原因分析：**更新脏数据到缓存**

  - ```sql
    【A写 B写】
    - A线程更新数据库
    - B线程更新数据库
    - B线程更新缓存
    - A更新【脏数据】到缓存
    ```

    

## 2. delete cache， update data

- 问题：读取依然是**旧数据**

- 原因分析：**缓存删除导致**

  - ```
    【A写 B读】
    - A线程删除缓存
    - B线程读取数据库（缓存已删除）
    - B线程更新缓存
    - A线程更新数据库
    ```

- 变种方案，双删除（直接采用方案3）：

  ```
  - 同上
  - A线程更新数据库后
  - A线程睡眠，等待B线程更新完缓存
    - 等待时间大小设置
      - B读取数据的一般时间 + 缓存更新时间+ mysql主从同步时间等 其他额外耗时计算
  - A线程再删除一次缓存
  ```

  

## 3. update data，delete cache

- 问题：读取依然是**旧数据**（同2）

- 原因分析：缓存过期，**写比读快导致**

  - ```
    【A写 B读】
    - 缓存过期
    - B读取数据（旧数据）
    - A更新数据
    - A删除缓存
    - B更新缓存（旧数据）
    ```

- 建议采取这种方案，读一般比写快，这种发生的可能性不大，其他分析

  - 读的业务更新缓存，写的业务只做删除缓存

## 4. [实现最终一致性](https://juejin.im/post/5b923de95188255c8e725c18#heading-4)

原因：以上没有实现我们想要的最终一致性，没有办法保证，delete cache 真正操作成功

方案：

```
- 删除操作失败之后，放在消息队列，等其他保证措施，进行重复尝试
- 预警通知
```



# 缓存一致性（强一致性）

问题：吞吐量低，并发低，适用  **读多写少**，不建议

分析：**写阻塞**，读阻塞（颗粒度控制在数据库操作）

```sql
【A写 B读】
- 缓存过期
- B线程读（旧数据）
- B线程无缓存，读数据库
- B加锁
- A线程阻塞
- B更新缓存
- B释放锁
- A线程获取锁
- A更新数据
- A删除缓存
```





[^1]: [一致性种类](https://cloud.tencent.com/developer/article/1015442)

